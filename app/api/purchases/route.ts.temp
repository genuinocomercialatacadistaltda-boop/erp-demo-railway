
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth-options';
import { prisma } from '@/lib/db';

// GET - Listar todas as compras
export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || !session.user || (session.user as any).userType !== 'ADMIN') {
      return NextResponse.json(
        { error: 'Acesso negado' },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(req.url);
    const status = searchParams.get('status');
    const supplierId = searchParams.get('supplierId');
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');

    const where: any = {
      customerId: null // ðŸ­ Apenas compras da fÃ¡brica/admin (nÃ£o dos clientes)
    };
    
    if (status) {
      where.status = status;
    }
    
    if (supplierId) {
      where.supplierId = supplierId;
    }
    
    if (startDate || endDate) {
      where.purchaseDate = {};
      if (startDate) {
        where.purchaseDate.gte = new Date(startDate);
      }
      if (endDate) {
        where.purchaseDate.lte = new Date(endDate);
      }
    }

    const purchases = await prisma.purchase.findMany({
      where,
      include: {
        Supplier: {
          select: {
            id: true,
            name: true,
            document: true,
            phone: true,
          },
        },
        BankAccount: {
          select: {
            id: true,
            name: true,
          },
        },
        PurchaseItem: {
          include: {
            RawMaterial: {
              select: {
                id: true,
                name: true,
                measurementUnit: true,
              },
            },
          },
        },
        PurchaseSupplyItems: {
          include: {
            Supply: {
              select: {
                id: true,
                name: true,
                unit: true,
                category: true,
              },
            },
          },
        },
      },
      orderBy: {
        purchaseDate: 'desc',
      },
    });

    // Mapear os dados para o formato esperado pelo frontend
    const mappedPurchases = purchases.map((purchase: any) => ({
      id: purchase.id,
      supplier: purchase.Supplier || { id: '', name: 'Fornecedor nÃ£o encontrado' },
      bankAccount: purchase.BankAccount || { id: '', name: 'Conta nÃ£o encontrada' },
      totalAmount: purchase.totalAmount,
      status: purchase.status,
      paymentMethod: purchase.paymentMethod || '',
      purchaseDate: purchase.purchaseDate,
      dueDate: purchase.dueDate,
      paidAt: purchase.paymentDate, // Corrigido: era paymentDate no schema
      notes: purchase.notes,
      items: purchase.PurchaseItem.map((item: any) => ({
        id: item.id,
        material: {
          id: item.RawMaterial.id,
          name: item.RawMaterial.name,
          sku: '', // Adicionar se necessÃ¡rio
          unit: item.RawMaterial.measurementUnit,
        },
        quantity: item.quantity,
        unitPrice: item.unitPrice,
      })),
      supplyItems: purchase.PurchaseSupplyItems.map((item: any) => ({
        id: item.id,
        supply: {
          id: item.Supply.id,
          name: item.Supply.name,
          unit: item.Supply.unit,
          category: item.Supply.category,
        },
        quantity: item.quantity,
        unitPrice: item.unitPrice,
      })),
      createdAt: purchase.createdAt,
    }));

    return NextResponse.json(mappedPurchases);
  } catch (error) {
    console.error('Erro ao buscar compras:', error);
    return NextResponse.json(
      { error: 'Erro ao buscar compras' },
      { status: 500 }
    );
  }
}

// POST - Criar nova compra
export async function POST(req: NextRequest) {
  try {
    console.log("ðŸŽ¯ POST /api/purchases CHAMADO");
    
    const session = await getServerSession(authOptions);
    
    if (!session || !session.user || (session.user as any).userType !== 'ADMIN') {
      console.log("âŒ Acesso negado - usuÃ¡rio nÃ£o Ã© ADMIN");
      return NextResponse.json(
        { error: 'Acesso negado' },
        { status: 403 }
      );
    }

    console.log("âœ… UsuÃ¡rio autenticado:", (session.user as any).email);

    const body = await req.json();
    console.log("ðŸ“¦ Body recebido:", JSON.stringify(body, null, 2));
    
    const {
      supplierId,
      items,
      supplyItems, // ðŸ†• Insumos
      purchaseDate,
      dueDate,
      paymentMethod,
      bankAccountId,
      creditCardId, // ðŸ’³ CartÃ£o de crÃ©dito
      installments = 1, // ðŸ’³ NÃºmero de parcelas
      invoiceNumber,
      invoiceUrl,
      notes,
      taxAmount = 0, // ðŸ†• Valor do imposto da nota
      expenseType = 'RAW_MATERIALS',
      status = 'PENDING',
    } = body;
    
    console.log("ðŸ“‹ Dados extraÃ­dos:", {
      supplierId,
      itemsCount: items?.length,
      supplyItemsCount: supplyItems?.length, // ðŸ†•
      purchaseDate,
      dueDate,
      paymentMethod,
      bankAccountId,
      taxAmount, // ðŸ†•
      status,
      expenseType
    });

    // ValidaÃ§Ãµes
    if (!supplierId) {
      return NextResponse.json(
        { error: 'Fornecedor Ã© obrigatÃ³rio' },
        { status: 400 }
      );
    }

    // ðŸ’³ Validar cartÃ£o de crÃ©dito se for o mÃ©todo de pagamento
    if (paymentMethod === 'CARTAO_CREDITO' && !creditCardId) {
      return NextResponse.json(
        { error: 'CartÃ£o de crÃ©dito Ã© obrigatÃ³rio para compras no cartÃ£o' },
        { status: 400 }
      );
    }

    // Validar que hÃ¡ pelo menos matÃ©rias-primas OU insumos
    if ((!items || items.length === 0) && (!supplyItems || supplyItems.length === 0)) {
      return NextResponse.json(
        { error: 'Adicione pelo menos um item (matÃ©ria-prima ou insumo) Ã  compra' },
        { status: 400 }
      );
    }

    if (!dueDate) {
      return NextResponse.json(
        { error: 'Data de vencimento Ã© obrigatÃ³ria' },
        { status: 400 }
      );
    }

    // Calcular total (matÃ©rias-primas + insumos + impostos)
    const rawMaterialsTotal = (items || []).reduce((sum: number, item: any) => {
      return sum + (item.quantity * item.unitPrice);
    }, 0);
    
    const suppliesTotal = (supplyItems || []).reduce((sum: number, item: any) => {
      return sum + (item.quantity * item.unitPrice);
    }, 0);
    
    const totalAmount = rawMaterialsTotal + suppliesTotal + (taxAmount || 0);
    
    console.log("ðŸ’° Totais calculados:", {
      rawMaterialsTotal,
      suppliesTotal,
      taxAmount: taxAmount || 0,
      totalAmount
    });

    // Gerar nÃºmero da compra
    const lastPurchase = await prisma.purchase.findFirst({
      orderBy: { createdAt: 'desc' },
    });

    const purchaseCount = lastPurchase 
      ? parseInt(lastPurchase.purchaseNumber.split('-')[2]) + 1 
      : 1;
    
    const now = new Date();
    const purchaseNumber = `COMP-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}-${String(purchaseCount).padStart(4, '0')}`;

    // ðŸ’³ VALIDAÃ‡ÃƒO PRÃ‰VIA: Verificar se cartÃ£o existe (sem bloquear por limite)
    if (paymentMethod === 'CARTAO_CREDITO' && creditCardId) {
      const cardValidation = await prisma.creditCard.findUnique({
        where: { id: creditCardId }
      });

      if (!cardValidation) {
        return NextResponse.json(
          { error: 'CartÃ£o nÃ£o encontrado' },
          { status: 404 }
        );
      }

      // âš ï¸ AVISO: NÃ£o bloqueamos compra por limite insuficiente
      const currentAvailable = cardValidation.availableLimit || cardValidation.limit;
      if (cardValidation.limit && cardValidation.limit > 0 && currentAvailable < totalAmount) {
        console.warn(`âš ï¸ ALERTA: Compra de R$ ${totalAmount.toFixed(2)} excede limite disponÃ­vel de R$ ${currentAvailable.toFixed(2)}`);
        console.warn(`âš ï¸ CartÃ£o: ${cardValidation.name} - Permitindo compra mesmo assim`);
      }
    }

    // Criar compra em transaÃ§Ã£o
    console.log("ðŸ”„ Iniciando transaÃ§Ã£o...");
    
    const purchase = await prisma.$transaction(async (tx: any) => {
      console.log("ðŸ” Buscando ou criando categoria 'Compra de Mercadoria'...");
      
      // Buscar ou criar categoria "Compra de Mercadoria"
      let category = await tx.expenseCategory.findFirst({
        where: { name: 'Compra de Mercadoria' },
      });

      if (!category) {
        console.log("ðŸ“ Categoria nÃ£o encontrada, criando nova...");
        category = await tx.expenseCategory.create({
          data: {
            name: 'Compra de Mercadoria',
            description: 'Compras de matÃ©rias-primas e produtos',
            color: '#10b981',
            isActive: true,
          },
        });
        console.log("âœ… Categoria criada:", category.id);
      } else {
        console.log("âœ… Categoria encontrada:", category.id);
      }

      // Buscar nome do fornecedor
      console.log("ðŸ” Buscando fornecedor:", supplierId);
      const supplier = await tx.supplier.findUnique({
        where: { id: supplierId },
      });
      
      if (!supplier) {
        console.log("âŒ Fornecedor nÃ£o encontrado:", supplierId);
        throw new Error(`Fornecedor com ID ${supplierId} nÃ£o encontrado`);
      }
      console.log("âœ… Fornecedor encontrado:", supplier.name);

      // ðŸ’³ NÃƒO criar despesa para cartÃ£o de crÃ©dito (jÃ¡ foi criada nas faturas)
      let expense = null;
      
      if (paymentMethod !== 'CARTAO_CREDITO') {
        // Criar a despesa no financeiro PRIMEIRO (apenas para outros mÃ©todos)
        console.log("ðŸ’° Criando despesa no financeiro...");
        console.log("Dados da despesa:", {
          description: `Compra de Mercadoria - ${supplier.name}`,
          amount: totalAmount,
          categoryId: category.id,
          bankAccountId: bankAccountId || null,
          supplierId: supplierId,
          dueDate: new Date(dueDate),
          status: status,
          expenseType: expenseType,
          paymentMethod: paymentMethod
        });
        
        expense = await tx.expense.create({
          data: {
            description: `Compra de Mercadoria - ${supplier.name}`,
            amount: totalAmount,
            categoryId: category.id,
            bankAccountId: bankAccountId || null,
            supplierId: supplierId,
            dueDate: new Date(dueDate),
            paymentDate: status === 'PAID' ? new Date() : null,
            status: status,
            expenseType: expenseType,
            paymentMethod: paymentMethod,
            notes: notes,
            referenceNumber: invoiceNumber,
            attachmentUrl: invoiceUrl,
            createdBy: (session.user as any).email,
          },
        });

        console.log('âœ… Despesa criada automaticamente:', expense.id);
      } else {
        console.log('ðŸ’³ CartÃ£o de crÃ©dito - Despesas jÃ¡ criadas nas faturas, pulando despesa normal');
      }

      // Criar a compra vinculada Ã  despesa (se existir)
      console.log("ðŸ“¦ Criando compra...");
      console.log("Dados da compra:", {
        purchaseNumber,
        supplierId,
        totalAmount,
        status,
        expenseType,
        purchaseDate: purchaseDate ? new Date(purchaseDate) : new Date(),
        dueDate: new Date(dueDate),
        paymentMethod,
        bankAccountId,
        expenseId: expense?.id || null, // ðŸ’³ null para cartÃ£o de crÃ©dito
        itemsCount: items.length
      });
      
      const newPurchase = await tx.purchase.create({
        data: {
          purchaseNumber,
          supplierId,
          customerId: null, // ðŸ­ Compra da fÃ¡brica/admin (nÃ£o do cliente)
          totalAmount,
          taxAmount: taxAmount || 0, // ðŸ†• Valor do imposto da nota
          status,
          expenseType,
          purchaseDate: purchaseDate ? new Date(purchaseDate) : new Date(),
          dueDate: new Date(dueDate),
          paymentDate: status === 'PAID' ? new Date() : null,
          paymentMethod,
          bankAccountId,
          expenseId: expense?.id || null, // ðŸ’³ null para cartÃ£o de crÃ©dito (despesas nas faturas)
          invoiceNumber,
          invoiceUrl,
          notes,
          createdBy: (session.user as any).email,
          paidBy: status === 'PAID' ? (session.user as any).email : null,
          PurchaseItem: items && items.length > 0 ? {
            create: items.map((item: any) => ({
              rawMaterialId: item.rawMaterialId,
              quantity: item.quantity,
              unitPrice: item.unitPrice,
              totalPrice: item.quantity * item.unitPrice,
              notes: item.notes,
            })),
          } : undefined,
          PurchaseSupplyItems: supplyItems && supplyItems.length > 0 ? {
            create: supplyItems.map((item: any) => ({
              supplyId: item.supplyId,
              quantity: item.quantity,
              unitPrice: item.unitPrice,
              totalPrice: item.quantity * item.unitPrice,
              notes: item.notes,
            })),
          } : undefined,
        },
        include: {
          Supplier: true,
          BankAccount: true,
          Expense: {
            include: {
              Category: true,
            },
          },
          PurchaseItem: {
            include: {
              RawMaterial: true,
            },
          },
          PurchaseSupplyItems: {
            include: {
              Supply: true,
            },
          },
        },
      });

      if (expense) {
        console.log('âœ… Compra criada e vinculada Ã  despesa:', newPurchase.id, 'â†’', expense.id);
      } else {
        console.log('âœ… Compra criada (sem despesa normal - cartÃ£o de crÃ©dito):', newPurchase.id);
      }

      // Atualizar estoque das matÃ©rias-primas e registrar mudanÃ§as de custo
      console.log("ðŸ“Š Atualizando estoque das matÃ©rias-primas...");
      for (const item of (items || [])) {
        console.log(`Atualizando matÃ©ria-prima ${item.rawMaterialId}: +${item.quantity}`);
        
        // Buscar custo atual antes da atualizaÃ§Ã£o
        const currentMaterial = await tx.rawMaterial.findUnique({
          where: { id: item.rawMaterialId },
          select: { costPerUnit: true, name: true },
        });
        
        const oldCost = currentMaterial?.costPerUnit || 0;
        const newCost = item.unitPrice;
        
        // Atualizar matÃ©ria-prima
        await tx.rawMaterial.update({
          where: { id: item.rawMaterialId },
          data: {
            currentStock: {
              increment: item.quantity,
            },
            costPerUnit: newCost,
          },
        });
        
        // Registrar mudanÃ§a de custo se houve alteraÃ§Ã£o
        if (Math.abs(oldCost - newCost) > 0.01) {
          console.log(`ðŸ’° Custo alterado: ${currentMaterial?.name} ${oldCost} â†’ ${newCost}`);
          
          await tx.costHistory.create({
            data: {
              rawMaterialId: item.rawMaterialId,
              oldCost,
              newCost,
              reason: 'PURCHASE',
              purchaseId: newPurchase.id,
              notes: `Compra ${purchaseNumber} - ${supplier.name}`,
            },
          });
          
          // Buscar receitas que usam esta matÃ©ria-prima
          const affectedRecipes = await tx.recipe.findMany({
            where: {
              Ingredients: {
                some: {
                  rawMaterialId: item.rawMaterialId,
                },
              },
            },
            select: { id: true },
          });
          
          // Atualizar lastCostUpdate das receitas afetadas
          if (affectedRecipes.length > 0) {
            console.log(`ðŸ“‹ Atualizando ${affectedRecipes.length} receita(s) que usam ${currentMaterial?.name}`);
            
            await tx.recipe.updateMany({
              where: {
                id: {
                  in: affectedRecipes.map((r: any) => r.id),
                },
              },
              data: {
                lastCostUpdate: new Date(),
              },
            });
          }
        }
      }
      console.log("âœ… Estoque de matÃ©rias-primas atualizado");

      // ðŸ†• Atualizar estoque dos insumos
      console.log("ðŸ“¦ Atualizando estoque dos insumos...");
      for (const item of (supplyItems || [])) {
        console.log(`Atualizando insumo ${item.supplyId}: +${item.quantity}`);
        
        // Buscar custo atual do insumo antes da atualizaÃ§Ã£o
        const currentSupply = await tx.productionSupplyGlobal.findUnique({
          where: { id: item.supplyId },
          select: { costPerUnit: true, name: true, currentStock: true },
        });
        
        const oldCost = currentSupply?.costPerUnit || 0;
        const newCost = item.unitPrice;
        
        // Atualizar insumo (estoque e custo)
        const updatedSupply = await tx.productionSupplyGlobal.update({
          where: { id: item.supplyId },
          data: {
            currentStock: {
              increment: item.quantity,
            },
            costPerUnit: newCost,
          },
        });
        
        // Registrar movimentaÃ§Ã£o de estoque do insumo
        await tx.supplyMovement.create({
          data: {
            supplyId: item.supplyId,
            type: 'IN',
            quantity: item.quantity,
            reason: 'PURCHASE',
            reference: newPurchase.id,
            notes: `Compra ${purchaseNumber} - ${supplier.name}`,
            createdBy: (session.user as any).email,
          },
        });
        
        console.log(`âœ… Insumo atualizado: ${currentSupply?.name} - Estoque: ${currentSupply?.currentStock} â†’ ${updatedSupply.currentStock}, Custo: R$ ${oldCost.toFixed(2)} â†’ R$ ${newCost.toFixed(2)}`);
      }
      console.log("âœ… Estoque de insumos atualizado");

      // Se jÃ¡ foi pago, registrar transaÃ§Ã£o bancÃ¡ria (exceto cartÃ£o de crÃ©dito)
      if (status === 'PAID' && bankAccountId && paymentMethod !== 'CARTAO_CREDITO') {
        // Deduzir do saldo da conta bancÃ¡ria
        const updatedAccount = await tx.bankAccount.update({
          where: { id: bankAccountId },
          data: {
            balance: {
              decrement: totalAmount,
            },
          },
        });

        // Registrar transaÃ§Ã£o
        await tx.transaction.create({
          data: {
            bankAccountId,
            type: 'EXPENSE',
            amount: totalAmount,
            description: `Compra ${purchaseNumber} - ${supplier?.name || 'Fornecedor'}`,
            referenceId: newPurchase.id,
            referenceType: 'PURCHASE',
            category: expenseType,
            date: new Date(),
            balanceAfter: updatedAccount.balance,
            createdBy: (session.user as any).email,
          },
        });

        console.log('ðŸ’³ TransaÃ§Ã£o bancÃ¡ria registrada para compra paga');
      } else if (paymentMethod === 'CARTAO_CREDITO') {
        console.log('ðŸ’³ Compra no cartÃ£o - transaÃ§Ã£o bancÃ¡ria nÃ£o registrada (serÃ¡ paga na fatura)');
      }

      return newPurchase;
    });

    console.log("ðŸŽ‰ Compra criada com sucesso!");
    return NextResponse.json(purchase, { status: 201 });
  } catch (error: any) {
    console.error('ðŸ’¥ ERRO AO CRIAR COMPRA:', error);
    console.error('Stack trace:', error?.stack);
    console.error('Mensagem:', error?.message);
    console.error('CÃ³digo:', error?.code);
    console.error('Meta:', error?.meta);
    
    // Retornar erro mais detalhado
    return NextResponse.json(
      { 
        error: 'Erro ao criar compra',
        details: error?.message || 'Erro desconhecido',
        code: error?.code
      },
      { status: 500 }
    );
  }
}
