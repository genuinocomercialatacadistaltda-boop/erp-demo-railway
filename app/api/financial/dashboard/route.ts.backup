export const dynamic = 'force-dynamic';


import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth-options";
import { prisma } from "@/lib/db";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";

// GET - Dashboard financeiro consolidado
export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session || (session.user as any)?.userType !== "ADMIN") {
      return NextResponse.json(
        { error: "N√£o autorizado" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(req.url);
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");

    // Definir per√≠odo padr√£o (m√™s atual)
    const start = startDate ? new Date(startDate) : new Date(new Date().setDate(1));
    const end = endDate ? new Date(endDate) : new Date();

    // 1. Buscar todas as contas banc√°rias com saldos
    const bankAccounts = await prisma.bankAccount.findMany({
      where: { isActive: true },
      orderBy: { name: "asc" }
    });

    const totalBalance = bankAccounts.reduce((sum: number, acc: any) => sum + acc.balance, 0);

    // 2. Buscar despesas por categoria (TODAS - pagas e pendentes) no per√≠odo
    // üîí CR√çTICO: Excluir despesas que s√£o de compras (Purchase !== null) para evitar duplica√ß√£o
    const expensesByCategory = await prisma.expense.groupBy({
      by: ["categoryId"],
      where: {
        Purchase: null, // üîë Apenas despesas normais (n√£o ligadas a compras)
        OR: [
          {
            // Despesas pagas no per√≠odo
            paymentDate: {
              gte: start,
              lte: end
            },
            status: "PAID"
          },
          {
            // Despesas pendentes com vencimento no per√≠odo
            dueDate: {
              gte: start,
              lte: end
            },
            status: "PENDING"
          }
        ]
      },
      _sum: {
        amount: true,
        feeAmount: true
      }
    });

    // 2.1. Buscar TAMB√âM despesas de CART√ÉO DE CR√âDITO por categoria
    // üîß CORRE√á√ÉO: Filtrar por purchaseDate (data de compet√™ncia - quando a despesa foi realizada)
    const creditCardExpensesByCategory = await prisma.creditCardExpense.groupBy({
      by: ["categoryId"],
      where: {
        purchaseDate: {
          gte: start,
          lte: end
        }
      },
      _sum: {
        amount: true
      }
    });

    // 2.2. Buscar APENAS COMPRAS SEM EXPENSE VINCULADA (para n√£o duplicar com despesas)
    // üîß CORRE√á√ÉO: Compras COM expense j√° est√£o sendo contadas em expensesByCategory
    // üîß Aqui buscamos APENAS compras que N√ÉO t√™m expense (ex: compras de cart√£o de cr√©dito antigas)
    const purchases = await prisma.purchase.findMany({
      where: {
        customerId: null, // üîë Apenas compras da f√°brica (admin)
        purchaseDate: {
          gte: start,
          lte: end
        },
        expenseId: null // üîë APENAS compras SEM expense (para n√£o duplicar!)
      },
      include: {
        Supplier: {
          select: {
            name: true
          }
        }
      }
    });

    console.log("üîç [DASHBOARD] Compras SEM expense vinculada:", purchases.length);

    // Agrupar compras por categoria (todas ser√£o "sem-categoria" porque n√£o t√™m expense)
    const purchasesByCategory = new Map<string, number>();
    purchases.forEach((purchase: any) => {
      // Compras sem expense v√£o para "sem-categoria"
      const categoryId = "sem-categoria";
      const current = purchasesByCategory.get(categoryId) || 0;
      purchasesByCategory.set(categoryId, current + purchase.totalAmount);
    });

    // Buscar nomes de TODAS as categorias (despesas normais + cart√£o)
    const expenseCategoryIds = [
      ...expensesByCategory.map((e: any) => e.categoryId),
      ...creditCardExpensesByCategory.map((e: any) => e.categoryId)
    ]
      .filter((id): id is string => id !== null) // remove null e garante tipo string
      .filter((id, index, self) => self.indexOf(id) === index); // remove duplicados

    // Buscar categorias de compras separadamente
    const purchaseCategoryIds = Array.from(purchasesByCategory.keys())
      .filter((id): id is string => id !== "sem-categoria")
      .filter((id, index, self) => self.indexOf(id) === index);

    const allCategoryIds = [...expenseCategoryIds, ...purchaseCategoryIds]
      .filter((id, index, self) => self.indexOf(id) === index);

    const categories = await prisma.expenseCategory.findMany({
      where: {
        id: {
          in: allCategoryIds
        }
      }
    });

    // Criar um mapa para somar APENAS despesas normais + cart√£o (SEM COMPRAS)
    const expenseCategoryMap = new Map<string, { categoryId: string; categoryName: string; categoryColor: string; amount: number }>();

    // Adicionar despesas normais (incluindo feeAmount)
    expensesByCategory.forEach((exp: any) => {
      if (!exp.categoryId) return;
      
      const category = categories.find((c: any) => c.id === exp.categoryId);
      const key = exp.categoryId;
      const existing = expenseCategoryMap.get(key);
      const totalAmount = (exp._sum.amount || 0) + (exp._sum.feeAmount || 0);
      
      if (existing) {
        existing.amount += totalAmount;
      } else {
        expenseCategoryMap.set(key, {
          categoryId: exp.categoryId,
          categoryName: category?.name || "Outros",
          categoryColor: category?.color || "#6B7280",
          amount: totalAmount
        });
      }
    });

    // Adicionar despesas de CART√ÉO DE CR√âDITO
    creditCardExpensesByCategory.forEach((exp: any) => {
      if (!exp.categoryId) return;
      
      const category = categories.find((c: any) => c.id === exp.categoryId);
      const key = exp.categoryId;
      const existing = expenseCategoryMap.get(key);
      
      if (existing) {
        existing.amount += exp._sum.amount || 0;
      } else {
        expenseCategoryMap.set(key, {
          categoryId: exp.categoryId,
          categoryName: category?.name || "Cart√£o de Cr√©dito",
          categoryColor: category?.color || "#6B7280",
          amount: exp._sum.amount || 0
        });
      }
    });

    // Criar um mapa separado APENAS para COMPRAS
    const purchaseCategoryMap = new Map<string, { categoryId: string; categoryName: string; categoryColor: string; amount: number }>();

    purchasesByCategory.forEach((amount, categoryId) => {
      if (categoryId === "sem-categoria") {
        purchaseCategoryMap.set("sem-categoria", {
          categoryId: "sem-categoria",
          categoryName: "Compras sem Categoria",
          categoryColor: "#9CA3AF",
          amount: amount
        });
      } else {
        const category = categories.find((c: any) => c.id === categoryId);
        purchaseCategoryMap.set(categoryId, {
          categoryId: categoryId,
          categoryName: category?.name || "Compras",
          categoryColor: category?.color || "#9CA3AF",
          amount: amount
        });
      }
    });

    const expensesByCategoryWithNames = Array.from(expenseCategoryMap.values());
    const purchasesByCategoryWithNames = Array.from(purchaseCategoryMap.values());

    // 3. Total de despesas no per√≠odo (despesas normais + cart√£o - pagas e pendentes)
    const totalExpensesInPeriod = expensesByCategoryWithNames.reduce(
      (sum, cat) => sum + cat.amount,
      0
    );

    // 3.1. Total de compras no per√≠odo (para incluir no saldo projetado)
    const totalPurchasesInPeriod = purchasesByCategoryWithNames.reduce(
      (sum, cat) => sum + cat.amount,
      0
    );

    console.log("üîç [DASHBOARD] Total de despesas no per√≠odo:", totalExpensesInPeriod);
    console.log("üîç [DASHBOARD] Total de compras no per√≠odo:", totalPurchasesInPeriod);

    // 4. Total de despesas pendentes
    const pendingExpenses = await prisma.expense.findMany({
      where: {
        status: "PENDING"
      },
      include: {
        Category: {
          select: {
            name: true,
            color: true
          }
        }
      },
      orderBy: { dueDate: "asc" },
      take: 30 // Pr√≥ximas 30 despesas a vencer
    });

    // 4.1.5 Buscar faturas de cart√£o de cr√©dito pendentes (n√£o pagas)
    const pendingCreditCardInvoices = await prisma.creditCardInvoice.findMany({
      where: {
        status: {
          in: ["OPEN", "CLOSED", "OVERDUE"]
        }
      },
      include: {
        CreditCard: {
          select: {
            name: true,
            color: true
          }
        }
      },
      orderBy: { dueDate: "asc" }
    });

    // Transformar faturas em formato compat√≠vel com despesas
    const creditCardInvoicesAsExpenses = pendingCreditCardInvoices.map((invoice: any) => {
      // Converter data para string no formato YYYY-MM-DD (sem hora) para evitar problemas de timezone
      // Pegar a data do banco e formatar apenas a parte da data
      const dueDateObj = new Date(invoice.dueDate);
      const year = dueDateObj.getUTCFullYear();
      const month = String(dueDateObj.getUTCMonth() + 1).padStart(2, '0');
      const day = String(dueDateObj.getUTCDate()).padStart(2, '0');
      const dueDateFormatted = `${year}-${month}-${day}T00:00:00.000Z`;
      
      return {
        id: invoice.id,
        description: `Fatura ${invoice.CreditCard.name} - ${format(new Date(invoice.referenceMonth), "MMM/yyyy", { locale: ptBR })}`,
        amount: invoice.totalAmount,
        dueDate: dueDateFormatted,
        Category: {
          name: "Cart√£o de Cr√©dito",
          color: invoice.CreditCard.color || "#8B5CF6"
        }
      };
    });

    // Combinar despesas normais com faturas de cart√£o
    const allPendingExpenses = [...pendingExpenses, ...creditCardInvoicesAsExpenses]
      .sort((a, b) => new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime())
      .slice(0, 30); // Limitar a 30 itens

    // 4.0. Buscar contas a receber pendentes (pr√≥ximos 30 dias)
    const thirtyDaysFromNow = new Date();
    thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);
    
    const pendingReceivables = await prisma.receivable.findMany({
      where: {
        status: "PENDING",
        dueDate: {
          lte: thirtyDaysFromNow
        }
      },
      include: {
        Customer: {
          select: {
            name: true,
            phone: true
          }
        }
      },
      orderBy: { dueDate: "asc" },
      take: 30 // Pr√≥ximos 30 recebimentos a vencer
    });

    let totalPendingExpenses = pendingExpenses.reduce(
      (sum: number, exp: any) => sum + exp.amount + (exp.feeAmount || 0),
      0
    );

    // 4.1. Adicionar despesas de cart√£o de cr√©dito com fatura N√ÉO PAGA (OPEN, CLOSED, OVERDUE)
    const pendingCreditCardExpenses = await prisma.creditCardExpense.aggregate({
      where: {
        OR: [
          {
            // Despesas em faturas abertas, fechadas ou vencidas (n√£o pagas)
            Invoice: {
              status: {
                in: ["OPEN", "CLOSED", "OVERDUE"]
              }
            }
          },
          {
            // Despesas sem fatura atribu√≠da ainda (ainda na fatura aberta)
            invoiceId: null
          }
        ]
      },
      _sum: {
        amount: true
      }
    });

    totalPendingExpenses += pendingCreditCardExpenses._sum.amount || 0;

    // 4.2. Adicionar COMPRAS PENDENTES (n√£o pagas) - APENAS DA F√ÅBRICA
    // üîß CORRE√á√ÉO: Excluir compras que J√Å t√™m expense vinculada (para n√£o duplicar)
    // üîß CORRE√á√ÉO: Excluir compras de cart√£o de cr√©dito (j√° est√£o nas CreditCardExpenses)
    const pendingPurchases = await prisma.purchase.aggregate({
      where: {
        customerId: null, // üîë Apenas compras da f√°brica (admin)
        status: "PENDING",
        expenseId: null, // üîë Apenas compras SEM expense (para n√£o duplicar)
        paymentMethod: { not: "CARTAO_CREDITO" } // üîë Excluir cart√£o (j√° contado acima)
      },
      _sum: {
        totalAmount: true
      }
    });

    totalPendingExpenses += pendingPurchases._sum.totalAmount || 0;
    console.log("üîç [DASHBOARD] Compras pendentes (sem expense, sem cart√£o):", pendingPurchases._sum.totalAmount || 0);

    // 5. Despesas vencidas
    const overdueExpenses = await prisma.expense.count({
      where: {
        status: "PENDING",
        dueDate: {
          lt: new Date()
        }
      }
    });

    // 6. Receitas do per√≠odo (pedidos)
    const ordersIncome = await prisma.order.aggregate({
      where: {
        createdAt: {
          gte: start,
          lte: end
        },
        status: {
          notIn: ["CANCELLED"]
        }
      },
      _sum: {
        total: true
      }
    });

    const totalIncome = ordersIncome._sum.total || 0;

    console.log("üîç [DASHBOARD] Total de receita (pedidos) no per√≠odo:", totalIncome);

    // 7. Contas a receber pendentes
    // üîß CORRE√á√ÉO: Incluir BOLETOS pendentes (que s√£o a principal fonte de receb√≠veis)
    // üîß CORRE√á√ÉO: Receivables SEM boletoId (para n√£o duplicar com boletos)
    
    // 7.1 Receivables pendentes SEM boleto vinculado
    const receivablesWithoutBoleto = await prisma.receivable.aggregate({
      where: {
        status: { in: ["PENDING", "OVERDUE"] },
        boletoId: null // üîë Apenas receivables SEM boleto (para n√£o duplicar)
      },
      _sum: {
        amount: true
      }
    });
    
    // 7.2 Boletos pendentes (principal fonte de receb√≠veis)
    const pendingBoletos = await prisma.boleto.aggregate({
      where: {
        status: { in: ["PENDING", "OVERDUE"] }
      },
      _sum: {
        amount: true
      }
    });
    
    const totalReceivable = (receivablesWithoutBoleto._sum.amount || 0) + (pendingBoletos._sum.amount || 0);
    
    console.log("üü¶ [DASHBOARD] A Receber - Receivables (sem boleto):", receivablesWithoutBoleto._sum.amount || 0);
    console.log("üü¶ [DASHBOARD] A Receber - Boletos pendentes:", pendingBoletos._sum.amount || 0);
    console.log("üü¶ [DASHBOARD] A Receber - TOTAL:", totalReceivable);

    // 7.1. Receita L√≠quida (valores efetivamente recebidos)
    const receivedIncome = await prisma.receivable.aggregate({
      where: {
        paymentDate: {
          gte: start,
          lte: end
        },
        status: "PAID"
      },
      _sum: {
        amount: true
      }
    });

    const totalReceivedIncome = receivedIncome?._sum?.amount || 0;

    console.log("üîç [DASHBOARD] Total de receita recebida no per√≠odo:", totalReceivedIncome);

    // 8. Transa√ß√µes recentes
    const recentTransactions = await prisma.transaction.findMany({
      include: {
        BankAccount: {
          select: {
            name: true,
            color: true
          }
        }
      },
      orderBy: { date: "desc" },
      take: 15
    });

    // 9. Saldo projetado (saldo atual + contas a receber - contas a pagar)
    const projectedBalance = totalBalance + totalReceivable - totalPendingExpenses;
    
    console.log("üü¶ [DASHBOARD] C√°lculo do Saldo Projetado:");
    console.log("   Saldo Total nas Contas:", totalBalance);
    console.log("   + Contas a Receber:", totalReceivable);
    console.log("   - Contas a Pagar:", totalPendingExpenses);
    console.log("   = Saldo Projetado:", projectedBalance);

    // 10. Agrupar despesas por tipo (OPERATIONAL, PRODUCTS, RAW_MATERIALS)
    const expensesByTypeMap = {
      OPERATIONAL: 0,
      PRODUCTS: 0,
      RAW_MATERIALS: 0
    };

    // Somar despesas normais por tipo (TODAS - pagas e pendentes)
    // üîí CR√çTICO: Excluir despesas de compras para evitar duplica√ß√£o
    const expensesByTypeQuery = await prisma.expense.groupBy({
      by: ["expenseType"],
      where: {
        Purchase: null, // üîë Apenas despesas normais (n√£o ligadas a compras)
        OR: [
          {
            // Despesas pagas no per√≠odo
            paymentDate: {
              gte: start,
              lte: end
            },
            status: "PAID"
          },
          {
            // Despesas pendentes com vencimento no per√≠odo
            dueDate: {
              gte: start,
              lte: end
            },
            status: "PENDING"
          }
        ]
      },
      _sum: {
        amount: true,
        feeAmount: true
      }
    });

    expensesByTypeQuery.forEach((exp: any) => {
      const type = exp.expenseType;
      if (type in expensesByTypeMap && exp._sum) {
        expensesByTypeMap[type as keyof typeof expensesByTypeMap] += 
          (exp._sum.amount || 0) + (exp._sum.feeAmount || 0);
      }
    });

    // Somar despesas de cart√£o por tipo
    // üîß CORRE√á√ÉO: Filtrar por Invoice.referenceMonth ao inv√©s de purchaseDate
    const creditCardExpensesByTypeQuery = await prisma.creditCardExpense.groupBy({
      by: ["expenseType"],
      where: {
        Invoice: {
          referenceMonth: {
            gte: start,
            lte: end
          }
        }
      },
      _sum: {
        amount: true
      }
    });

    creditCardExpensesByTypeQuery.forEach((exp: any) => {
      const type = exp.expenseType;
      if (type in expensesByTypeMap) {
        expensesByTypeMap[type as keyof typeof expensesByTypeMap] += 
          (exp._sum.amount || 0);
      }
    });

    // Somar compras (sempre RAW_MATERIALS)
    expensesByTypeMap.RAW_MATERIALS += purchasesByCategoryWithNames.reduce(
      (sum, cat) => sum + cat.amount,
      0
    );

    return NextResponse.json({
      summary: {
        totalBalance,
        totalIncome,
        totalReceivedIncome,
        totalExpensesPaid: totalExpensesInPeriod,
        totalPurchasesPaid: totalPurchasesInPeriod,
        totalPendingExpenses,
        totalReceivable,
        projectedBalance,
        overdueExpensesCount: overdueExpenses
      },
      expensesByType: expensesByTypeMap,
      bankAccounts,
      expensesByCategory: expensesByCategoryWithNames,
      purchasesByCategory: purchasesByCategoryWithNames,
      pendingExpenses: allPendingExpenses, // Inclui despesas normais + faturas de cart√£o
      pendingReceivables: pendingReceivables,
      recentTransactions
    });
  } catch (error) {
    console.error("Erro ao buscar dashboard:", error);
    return NextResponse.json(
      { error: "Erro ao buscar dashboard" },
      { status: 500 }
    );
  }
}
